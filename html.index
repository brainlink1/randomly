<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>crimson Â· name picker</title>
    <!-- canvas-confetti for celebration effect (red & white) -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: #f5f5f5;
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 20px;
        }

        .picker-card {
            max-width: 700px;
            width: 100%;
            background: #FFFFFF;
            border-radius: 28px;
            box-shadow: 0 20px 35px -8px rgba(0, 0, 0, 0.15), 0 8px 10px -6px rgba(0, 0, 0, 0.05);
            padding: 32px 28px;
            transition: all 0.2s ease;
        }

        h1 {
            font-weight: 600;
            font-size: 2.1rem;
            letter-spacing: -0.02em;
            color: #1e1e1e;
            margin-bottom: 28px;
            border-left: 8px solid #DC143C;
            padding-left: 20px;
        }

        /* accent red : #DC143C (crimson) */
        .red-btn {
            background: #DC143C;
            border: none;
            color: white;
            font-weight: 600;
            padding: 10px 22px;
            border-radius: 60px;
            font-size: 0.95rem;
            cursor: pointer;
            box-shadow: 0 6px 14px rgba(220, 20, 60, 0.25);
            transition: background 0.15s, transform 0.1s, box-shadow 0.2s;
            border: 1px solid rgba(255,255,255,0.2);
            letter-spacing: 0.3px;
        }

        .red-btn:hover {
            background: #b01030;
            box-shadow: 0 10px 18px rgba(180, 0, 30, 0.35);
            transform: scale(1.02);
        }

        .red-btn:active {
            transform: scale(0.97);
            box-shadow: 0 4px 8px rgba(180, 0, 30, 0.4);
        }

        .red-btn:disabled {
            opacity: 0.4;
            pointer-events: none;
            filter: grayscale(0.3);
            transform: none;
            box-shadow: none;
        }

        .input-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 22px;
            align-items: flex-start;
        }

        .input-group input, .input-group textarea {
            flex: 1 1 200px;
            padding: 14px 18px;
            border: 1.5px solid #eaeaea;
            border-radius: 40px;
            font-size: 1rem;
            background: #FFFFFF;
            transition: 0.2s;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.02);
        }

        .input-group textarea {
            border-radius: 24px;
            resize: vertical;
            min-height: 70px;
            font-family: inherit;
        }

        .input-group input:focus, .input-group textarea:focus {
            outline: none;
            border-color: #DC143C;
            box-shadow: 0 0 0 4px rgba(220, 20, 60, 0.15);
        }

        .names-list-container {
            background: #fafafa;
            border-radius: 32px;
            padding: 20px 16px;
            margin: 28px 0 24px;
            border: 1px solid #efefef;
            box-shadow: inset 0 2px 4px #f0f0f0;
        }

        .names-list-container h3 {
            font-size: 1rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #7c7c7c;
            margin-bottom: 16px;
            margin-left: 6px;
        }

        #namesList {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 12px 12px;
            align-items: center;
        }

        .name-chip {
            background: white;
            border-radius: 40px;
            padding: 8px 16px 8px 20px;
            font-size: 1rem;
            font-weight: 500;
            color: #232323;
            box-shadow: 0 4px 10px rgba(0,0,0,0.02), 0 0 0 1.5px #f0f0f0;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            transition: all 0.15s;
        }

        .name-chip:hover {
            box-shadow: 0 6px 14px rgba(220,20,60,0.08), 0 0 0 1.5px #DC143C;
        }

        .remove-name {
            background: none;
            border: none;
            color: #DC143C;
            font-weight: 700;
            font-size: 1.3rem;
            line-height: 1;
            cursor: pointer;
            padding: 0 4px;
            transition: 0.1s;
            opacity: 0.7;
        }

        .remove-name:hover {
            opacity: 1;
            transform: scale(1.2);
            color: #a00b2f;
        }

        /* display area for countdown / shuffle / winner */
        .display-area {
            background: #f9f9f9;
            border-radius: 48px;
            padding: 30px 20px;
            margin: 30px 0 28px;
            text-align: center;
            border: 1px solid #eee;
            box-shadow: inset 0 2px 7px #f0f0f0, 0 15px 25px -15px rgba(0,0,0,0.1);
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .countdown, .shuffle, .winner {
            transition: opacity 0.35s ease, visibility 0.35s;
            width: 100%;
        }

        .countdown {
            font-size: 7rem;
            font-weight: 800;
            line-height: 1;
            color: #DC143C;
            text-shadow: 0 5px 15px rgba(220,20,60,0.3);
            margin-bottom: 5px;
        }

        .shuffle {
            font-size: 2.2rem;
            font-weight: 600;
            color: #333;
            letter-spacing: 1px;
            min-height: 4rem;
            transition: opacity 0.15s;
            word-break: break-word;
        }

        .winner {
            font-size: 4rem;
            font-weight: 700;
            color: #DC143C;
            text-shadow: 0 3px 10px rgba(220,20,60,0.4);
            word-break: break-word;
        }

        /* hide helper */
        .hidden {
            opacity: 0 !important;
            visibility: hidden !important;
            pointer-events: none;
            transition: opacity 0.3s, visibility 0s 0.3s;
        }

        /* countdown pulse animation */
        .pulse-number {
            animation: pulse 0.4s cubic-bezier(0.2, 0.9, 0.3, 1.2) forwards;
        }

        @keyframes pulse {
            0% { transform: scale(0.9); opacity: 0.8; }
            50% { transform: scale(1.3); opacity: 1; text-shadow: 0 0 20px #ff4d4d; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* winner zoom / slide */
        .zoom-winner {
            animation: zoomIn 0.5s ease-out forwards;
        }

        @keyframes zoomIn {
            0% { opacity: 0; transform: scale(0.2) translateY(30px); }
            70% { transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }

        /* shuffle fade effect (smooth name changes) */
        .shuffle {
            transition: opacity 0.08s;
        }

        .actions {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 16px;
            margin-top: 20px;
        }

        .actions .red-btn {
            min-width: 130px;
            padding: 14px 24px;
            font-size: 1.1rem;
        }

        #resetBtn {
            background: #6c6c6c;
            box-shadow: 0 6px 14px rgba(100,100,100,0.25);
        }
        #resetBtn:hover {
            background: #4f4f4f;
        }

        .info-hint {
            font-size: 0.85rem;
            color: #a6a6a6;
            margin-top: 8px;
            margin-left: 10px;
        }

        hr {
            border: 0.5px solid #f0f0f0;
            margin: 20px 0 10px;
        }
    </style>
</head>
<body>
<div class="picker-card">
    <h1>ðŸŽ² crimson picker</h1>

    <!-- add single name -->
    <div class="input-group">
        <input type="text" id="singleNameInput" placeholder="e.g. Alice" autocomplete="off">
        <button class="red-btn" id="addSingleBtn">+ Add name</button>
    </div>

    <!-- bulk paste area -->
    <div class="input-group">
        <textarea id="bulkNames" placeholder="Paste list: one name per line Â·Â·Â·&#10;Hugo&#10;Olivia&#10;Lena"></textarea>
        <button class="red-btn" id="addBulkBtn">â†“ Add list</button>
    </div>

    <!-- list of entered names -->
    <div class="names-list-container">
        <h3>ðŸ“‹ contestants</h3>
        <ul id="namesList">
            <!-- filled dynamically -->
        </ul>
        <div class="info-hint">click âœ• to remove</div>
    </div>

    <!-- dynamic display: countdown + shuffle + winner -->
    <div class="display-area">
        <div id="countdownDisplay" class="countdown hidden"></div>
        <div id="shuffleDisplay" class="shuffle hidden"></div>
        <div id="winnerDisplay" class="winner hidden"></div>
    </div>

    <!-- action buttons -->
    <div class="actions">
        <button class="red-btn" id="startBtn" disabled>â–¶ Start</button>
        <button class="red-btn" id="pickAgainBtn" disabled>âŸ³ Pick again</button>
        <button class="red-btn" id="resetBtn">âœ• Reset</button>
    </div>
</div>

<script>
    (function() {
        // --- state ---
        let names = [];                     // array of name strings
        let isRunning = false;               // countdown active?
        let shuffleInterval = null;
        let countdownTimeouts = [];           // store setTimeout ids for cleanup

        // DOM elements
        const singleInput = document.getElementById('singleNameInput');
        const addSingleBtn = document.getElementById('addSingleBtn');
        const bulkText = document.getElementById('bulkNames');
        const addBulkBtn = document.getElementById('addBulkBtn');
        const namesListEl = document.getElementById('namesList');
        const startBtn = document.getElementById('startBtn');
        const pickAgainBtn = document.getElementById('pickAgainBtn');
        const resetBtn = document.getElementById('resetBtn');

        const countdownDisplay = document.getElementById('countdownDisplay');
        const shuffleDisplay = document.getElementById('shuffleDisplay');
        const winnerDisplay = document.getElementById('winnerDisplay');

        // helper: update button states (enable/disable) based on names length + running
        function updateButtons() {
            const hasNames = names.length > 0;
            // start & pickAgain: only enabled if names exist and NOT running
            if (!isRunning) {
                startBtn.disabled = !hasNames;
                pickAgainBtn.disabled = !hasNames;
            } else {
                startBtn.disabled = true;
                pickAgainBtn.disabled = true;
            }
            // reset always enabled (even during run, we allow interruption)
            resetBtn.disabled = false;
        }

        // stop all ongoing animations / timers (for reset or safety)
        function haltAllAnimations() {
            if (shuffleInterval) {
                clearInterval(shuffleInterval);
                shuffleInterval = null;
            }
            if (countdownTimeouts.length) {
                countdownTimeouts.forEach(id => clearTimeout(id));
                countdownTimeouts = [];
            }
            isRunning = false;
        }

        // clear displays, hide all, reset text
        function resetDisplay() {
            // hide all displays
            countdownDisplay.classList.add('hidden');
            shuffleDisplay.classList.add('hidden');
            winnerDisplay.classList.add('hidden');
            // reset text
            countdownDisplay.textContent = '';
            shuffleDisplay.textContent = '';
            winnerDisplay.textContent = '';
        }

        // render the name list (with remove buttons)
        function renderNameList() {
            namesListEl.innerHTML = '';
            names.forEach((name, index) => {
                const li = document.createElement('li');
                li.className = 'name-chip';
                li.innerHTML = `${escapeHtml(name)} <button class="remove-name" data-index="${index}" aria-label="remove">âœ•</button>`;
                namesListEl.appendChild(li);
            });

            // attach remove events
            document.querySelectorAll('.remove-name').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = btn.getAttribute('data-index');
                    if (index !== null) {
                        // remove name
                        names.splice(index, 1);
                        renderNameList();
                        // if list becomes empty during running? we don't force stop, but button states update
                        if (names.length === 0 && isRunning) {
                            // optionally stop: but we let reset handle. For safety halt and reset.
                            haltAllAnimations();
                            isRunning = false;
                            resetDisplay();
                        }
                        updateButtons();
                        // if no names, also hide winner/ displays? not necessary
                    }
                });
            });
        }

        // simple escape for innerHTML safety
        function escapeHtml(unsafe) {
            return unsafe.replace(/[&<>"']/g, function(m) {
                if(m === '&') return '&amp;'; if(m === '<') return '&lt;'; if(m === '>') return '&gt;'; if(m === '"') return '&quot;'; return '&#039;';
            });
        }

        // --- add single name ---
        addSingleBtn.addEventListener('click', () => {
            const val = singleInput.value.trim();
            if (val === '') return;
            names.push(val);
            renderNameList();
            singleInput.value = '';
            updateButtons();
        });

        // --- bulk add names (split by newline) ---
        addBulkBtn.addEventListener('click', () => {
            const raw = bulkText.value;
            if (raw.trim() === '') return;
            const lines = raw.split(/\n/);
            let added = 0;
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed !== '') {
                    names.push(trimmed);
                    added++;
                }
            });
            if (added > 0) {
                renderNameList();
                bulkText.value = '';
                updateButtons();
            }
        });

        // --- reset everything ---
        resetBtn.addEventListener('click', () => {
            haltAllAnimations();
            isRunning = false;
            names = [];
            renderNameList();
            resetDisplay();
            updateButtons();
        });

        // --- core function: start the picker countdown ---
        function beginSelection() {
            if (isRunning || names.length === 0) return;

            // clean any previous leftover timers
            haltAllAnimations();
            resetDisplay();

            isRunning = true;
            updateButtons();

            // show countdown & shuffle, hide winner
            countdownDisplay.classList.remove('hidden');
            shuffleDisplay.classList.remove('hidden');
            winnerDisplay.classList.add('hidden');

            // initial countdown = 3
            let count = 3;
            countdownDisplay.textContent = count;
            // add pulse animation
            countdownDisplay.classList.add('pulse-number');
            setTimeout(() => countdownDisplay.classList.remove('pulse-number'), 400);

            // start shuffling names rapidly (every 80ms)
            shuffleInterval = setInterval(() => {
                if (names.length > 0) {
                    const randomIdx = Math.floor(Math.random() * names.length);
                    shuffleDisplay.textContent = names[randomIdx];
                } else {
                    shuffleDisplay.textContent = 'â€”';
                }
            }, 70);  // rapid cycling

            // recursive countdown using timeouts
            function tick(nextVal) {
                if (nextVal > 0) {
                    countdownDisplay.textContent = nextVal;
                    countdownDisplay.classList.add('pulse-number');
                    setTimeout(() => countdownDisplay.classList.remove('pulse-number'), 300);

                    const timeoutId = setTimeout(() => tick(nextVal - 1), 1000);
                    countdownTimeouts.push(timeoutId);
                } else {
                    // countdown finished -> pick winner
                    if (shuffleInterval) {
                        clearInterval(shuffleInterval);
                        shuffleInterval = null;
                    }

                    if (names.length === 0) {
                        // edge: list became empty during countdown -> reset
                        haltAllAnimations();
                        isRunning = false;
                        resetDisplay();
                        updateButtons();
                        return;
                    }

                    // select random winner
                    const winner = names[Math.floor(Math.random() * names.length)];

                    // hide countdown & shuffle, show winner with animation
                    countdownDisplay.classList.add('hidden');
                    shuffleDisplay.classList.add('hidden');
                    winnerDisplay.classList.remove('hidden');
                    winnerDisplay.textContent = winner;
                    winnerDisplay.classList.add('zoom-winner');
                    setTimeout(() => winnerDisplay.classList.remove('zoom-winner'), 600);

                    // ðŸŽ‰ confetti (red & white)
                    confetti({
                        particleCount: 120,
                        spread: 80,
                        origin: { y: 0.6 },
                        colors: ['#DC143C', '#FF0000', '#FFFFFF', '#FF8A8A']
                    });
                    // small second burst
                    setTimeout(() => {
                        confetti({
                            particleCount: 60,
                            spread: 40,
                            origin: { y: 0.5, x: 0.4 },
                            colors: ['#DC143C', '#FFFFFF']
                        });
                    }, 180);

                    // done
                    isRunning = false;
                    updateButtons();
                }
            }

            // start countdown: after showing 3, wait 1s then tick(2)
            const timeoutId = setTimeout(() => tick(2), 1000);
            countdownTimeouts.push(timeoutId);
        }

        // --- start & pick again both call beginSelection ---
        startBtn.addEventListener('click', beginSelection);
        pickAgainBtn.addEventListener('click', beginSelection);

        // extra: pressing Enter in single input triggers add
        singleInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addSingleBtn.click();
            }
        });

        // initial render & button state (empty)
        renderNameList();
        updateButtons();
        resetDisplay();  // everything hidden

        // if user adds first name, buttons become active.
    })();
</script>
</body>
</html>
